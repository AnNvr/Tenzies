# Tenzies
 practice on props, state and effect

1. SET UP LAYOUT: first of all, drafting the layout with some basic CSS to render the idea and working over it afterward;

2. DIE COMPONENTS: Since I don't have an array of objects with an id yet, I start with defining a Die component to pass props for rendering the props.value in a text element. The value given to the props will be initially hard code, just for initial rendering.

3. BREAKDOWN - GENERATE ARRAY: Now I can create an array of 10 random numbers to iterate over and render it to screen. I define a function allNewDice() that returns the array of 10 random numbers between 1-6 inclusive. I have different ways to create an array to iterate over it: I can use an array constructor, or I can define an empty array, iterate with for...loop 10 times, and push a random number in it. I decided to use an array constructor to test a method I never used before, and reduce the lines of code (UPDATED TO FOR..LOOP LATER)

4. BREAKDWON - MAP OVER THE ARRAY: I create a new state to hold the value of the array returned in the function allNewDice(). Since the function holds the array, I assign the function to the original state. I map over state array, and return the Die component assigning key and value. The props value is equal to the random number generated in the body function of the array constructor.

5. BUTTON - I need a button to fire up the game and call the function allNewDice(). I create an handleClick() function and I fire up the setter function passing allNewDice as an argument.

6. CHANGE NUMBERS TO OBJECTS: I need to hold dice in place while the button rolls the other dice. I opted to refactor the code to make it looks more comprehensible for learning purposes and swap the Array constructor with a for...loop to iterate over an empty array to populate with the values generated by Math.random().
But to in order to add more information about a die whether is held or not, I need to turn the array of numbers in an array of Objects with properties, including a prop I call isHeld = boolean. By default I set this property to false.

The logic where I generate random numbers to push into the array is here:
diceArray.push(Math.ceil(Math.random() * 6))
Instead of pushing numbers, I will push objects and assign the random numbers to the value prop.

7. HOLD DICE pt.1: I need to define a function in <App /> to pass down to each <Die /> component. In this way I know which <Die /> component is hold. I can take advantage of the ID implementation. Here is the breakdown:


- HOLD DICE pt.2: I create a function holdDice() which takes ID as a parameter, and I console.log(id) just for testing. In the child component <Die /> I define a property onClick with an anonymous callback fn that access to the id of the clicked object.
Once its tested, I am ready to swap the console.log(id) with a code that flip isHeld property.

- HOLD DICE pt.3: holdDice() takes a parameter ID, and when invoked it fires up the setter function for which it map over the previous state and, if the id of the object matches with the parameter I passed, it returns an updated array with the properties I have flipped.

- HOLD DICE pt.4: rollDice() has to be updated. I cannot keep rolling dice even when isHeld is set to true. So, I updated the code in the fn rollDice() for which I update the previous state, I map over it and return an item array, I check if the property isHeld is set to false in order to keep generating random numbers while keeping the array untouched for objects for which the isHeld property is set to true.

8. END OF THE GAME pt.1: The scope of the game is to roll until all dice are the same. Once that happens, the button should turn into a "Reset Game". To recognise if the state of the game is Won or ongoing, I need to set a state that I called "tenzies" equal to false. Also, I need an effect that runs every time the dice state array changes. Keeping two or more states in sync requires to handle effects in some way. In this case, I need to see wether or not the dice state array is updated with all the same numbers and the game is won setting the tenzies state to true.

- END OF THE GAME pt.2: in the effect I want to check all dice for the winning conditions. The two conditons are: all dice are held, and all dice have the same value.
I can use the array.every() method to check if a condition is true for all the elements in the array. I take the state dice, I apply the .every() and for each die I check if the property isHeld of every die is true before to return true for all elements. This tests one condition; since I have another condition to test, it's a good idea store them into two separate variables

const allHeld = dice.every(die => die.isHeld);

The second condition checks if all dice have the same value. I don't have a specific value for each dice, are random numbers. For this type cf check, I can compare the current value with an arbitrary value, for example the value of the first die in the array:

const arbitraryValue = dice[0].value;

const allSameValue = dice.every(die => die.value === arbitraryValue)

if (allHeld && allSameValue) {setTenzies(true)}

- END OF GAME pt.3: At this point, all I need is to set a new game by clicking the button.
After conditionally rendering the button text according to the tenzies state (truthy === "New Game" / falsy === "Roll"). I can create a new function that set both the states tenzies to false and dice to allNewDices() and conditionally rendering the function in the onClick listener. Even better, I can just update the existing rollDice function to run only IF tenzies is not true and the game is not won, else it updates tenzies to false and updateds dice to generate allNewDices()

EXTRA CREDITS:
1. CSS: put real dots on dice
2. Track the number of rolls
3. Track the time it took to win
4. Save the best time to localStorage

1. RESEARCH ONGOING.

2. BREAKDOWN: it takes a counter that increment the value of the original state related to the counter. The function rollDice() listen for a count any time is fired up; it updates the state of the counter variable incrementing +1. When the function rollDice() is ready for a new game, it sets the setRollCount() to its initial value of 0.

3. BREAKDOWN: setInterval has an asynchronous nature, as such it has to be handled in useEffect. I set a new useEffect which holds the logic: Interval is the identifier for the interval created by setInterval(); I declare the interval to an empty identifier ready to be populated by the time ongoing, and I check if tenzies is set to true so I clear the interval if the game is won; otherwise I declare interval as whatever the setInterval() method returns me. In this case, I want the setInterval() to update the timer state array of 1 second at the time. Finally, very important step, I declare the cleanup function to cleanup the interval from any value when the component is unmount or when the game is won.

In short: the effect for the timer starts a time when tenzies is false, it updated the timer state array every second, and if tenzies flips to true, it cleanup the interval stopping the timer.

4. BREAKDOWN: The flow is: start a new game, play and win the game, collect the time, and updated the localStorage with the best time.
In order to save the best time to localStorage and parse it: firstly, time state initialisation. I need to set a timer state array with default value of 0 and it's the array that is going to store the time generated by setInterval().
Also, I need an collection of times where to "filter" the best time to save in localStorage. Thus, I need two states: once to collect the times of game sessions, a timer collection state with default value of an empty array, and one to store the best time out of the that collection, which its default value is parsed from localStorage. It's parsed as an integer.

The effect for updating timer collection and best time runs when tenzies changes. If tenzies is true, it updates timerCollection with the current timer value, calculates the minimum time, and it updates bestTime setting the value to localStorage.

Finally, rollDice() check over tenzies value. If it's false, it rolls the dice, increment the roll count, and continues the timer. If it's true, it resets the game by flipping tenzies to false, rolling the dice and resetting either roll count and timer.
